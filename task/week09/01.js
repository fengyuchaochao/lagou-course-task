/**
 * 1、Vue 3.0 性能提升主要是通过哪几方面体现的？
 *
 *  1。 响应式系统升级，vue3.0采用proxy速度更快，代码更简洁，不需要做额外的兼容处理
 *  2。 编译优化：vue3.0标记和提升了所有的静态跟节点，diff的时候只需要对比动态内容，而且加了缓存函数，diff速度更快。
 *  3。 优化打包体积，移除了inline-template等不常用的api，同时更好的支持了tree shaking,支持按需引入，代码体积更小。
 * */

/**
 * 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
 *  传递的Options Api 在随着页面越来越复杂，子功能越来越多时，同一功能的代码就被分散到了data,methods等各个配置中，使得代码比较分散，代码不容易维护，
 *
 *  而Composition Api目的就是解决这个问题，可以将相同功能的代码维护在一起，即一个函数中，然后通过setup引入，这样代码逻辑更加清晰，也可以更好的实现复用。
 * */


/**
 * 3、Proxy 相对于 Object.defineProperty 有哪些优点？
 *
 *  首先，proxy解决了Object.defineProperty的两个最明显的问题：
 *  1。设置新属性，默认不是响应式数据，需要手动调用$set
 *  2。通过索引修改数组元素，length属性时，也不是响应式 ，需要单独处理
 *  3。删除某个对象的属性时，也不是响应式的
 *
 *  而proxy本身支持了很多种情况额拦截，包括get/set/deleteProperty，还有其他例如has等，所以proxy实现数据拦截会更加方便直接友好。
 * */


/**
 *
 * 4、Vue 3.0 在编译方面有哪些优化？
 *  1。 fragment
 *  2. 静态提升
 *  3。 patch flag
 *  4. 缓存时间处理函数
 *
 * */

/**
 * 5、Vue.js 3.0 响应式系统的实现原理？
 *
 * 核心是采用Proxy实现对数据的劫持，首先通过reactive/ref等函数将数据变成一个响应式数据，同时在get中收集依赖，在set中触发更新，
 *
 * 依赖收集的核心是维护了一个targetMap => depsMap => set， set中存放的就是每个属性所绑定的依赖，即存放这多个回调函数。
 *
 * */
