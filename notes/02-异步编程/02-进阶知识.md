

## 回调函数


回调函数也是一个函数，它具有函数的所有特征，

回调函数相对于普通函数来说，**主要区别它的调用方式，只有当某个函数被当作参数，传递给另外一个函数时，然后在函数内部调用，我们才该函数为回调函数。**


#### 同步回调函数

我们来通过代码体会一下：
```
let arr = [1, 2, 3, 4];
let handle = function (item, index) {
    console.log(item, index);
}
arr.forEach(handle);
```
分析：代码中handle函数就被当作参数传进了forEach函数中，并且实际执行也是在forEach函数中执行的，所以我们把该函数成为同步回调函数。


相对应的也有异步回调函数，同步回调函数是在函数内部执行的，比较简单，但是异步回调函数是在什么时机，什么位置执行的呢？

#### 异步回调函数

```
let handle = function () {
    
}
setTimeout(handle, 3000);
```

分析：此处的handle函数就是一个异步回调函数。


## 进程与线程

* **线程**：例如，我们的javascript语言，就是单线程语言，也就是说同一时刻只有一个线程来执行代码，而类似java这样的语言，支持多线程，即同一时刻可以有多个线程去并行执行代码，很显然，多线程的执行效率会更高。
* **进程**：**一个进程就是一个程序的运行实例。** 详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

![image](http://note.youdao.com/yws/res/9557/BC2A39B0BFC34FF9BAD473C5C9196C46)

从图中可以看到：**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**

接下来，我们看一下进程与线程的关系：

1.  进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2.  线程之间共享进程中的数据。
3.  当一个进程关闭之后，操作系统会回收进程所占用的内存。
4.  进程之间的内容相互隔离。


## 浏览器架构模型


#### 单进程浏览器时代

早期浏览器中，采用的就是单进程机制，即所有的功能，包含网络，插件，页面渲染等运行在不同的线程里，但是都是运行在一个进程里。

![image](http://note.youdao.com/yws/res/9565/6351D14049FC44E3B0B7658DDD054CB3)

很显然，采用单进程机制，只要其中有一个线程发生问题，就会导致整个进程挂掉，尤其早起浏览器的插件很容易崩掉，所以就导致浏览器单进程机制所带来的一些不稳定问题。


#### 多进程浏览器时代

那随着浏览器的不断发展与改进，就逐渐支持了多进程机制。以下是最新浏览器的架构模型：

![image](http://note.youdao.com/yws/res/9576/E438418C524A4717A60A030C8DE9CE1F)

我们可以看到现代浏览器有多个进程，来分别处理相应的场景：

1. 浏览器主进程: 主要负责页面交互，显示，以及子进程的管理
2. 网络进程：负责页面的网络资源加载
3. 渲染进程：即html,css,javascript等资源的渲染，最终形成页面，每一新tab都会对应一个渲染进程。
4. 插件进程：即负责浏览器插件的运行，因插件容易崩溃，所以放到单独的进程来维护，如果崩溃，对其他进程也不受影响。
5. GPU进程：一般采用GPU进程进行绘制。


这也就是解释了，为什么当我们打开一个新tab以后，在浏览器任务管理器中查看会有很多进程。

![image](http://note.youdao.com/yws/res/9591/E06E745FF436410BB85149CAEBECD921)


## 消息队列和事件循环系统

上面我们介绍了浏览器的多进程机制，其中渲染进程可能是我们会频繁用到的，因为html，css,javascript的加载运行等都是主要依赖该进程实现，同时也会与其他进程配合交互，最终显示出来。


**每个渲染进程都有一个对应的主线程**，并且主线程很忙，既要处理dom，布局计算，还有各种输入点击事件，所以如何有条不紊的保证这些任务能够正常执行呢？这就是消息队列和事件循环系统要解决的问题。

以下是浏览器执行js代码的整个过程：

![image](http://note.youdao.com/yws/res/9606/87E37291FC2C467EA17607E0A03BBEE0)


我们来解释一下：
1. 主体过程就是渲染进程的主线程来执行。
2. 消息队列：主要就是存放我们在代码执行过程中产生的任务（准确来说是宏任务），以及各种点击事件，网络资源加载等产生的任务。
3. 事件循环机制：即渲染主线程有一个类似轮询器的工具，它可以不断轮询消息队列中是否有任务，有的话，则依次取出任务执行。
4. 除了主线程，浏览器还提供了IO线程，同时渲染进程配合其他进程，例如网络进程等，最终保证js代码的正常运行。


![image](http://note.youdao.com/yws/res/9621/030B88B71617473AB623EEA20D723450)

![image](http://note.youdao.com/yws/res/9622/BBA707A3F57146F9B944B7FBFEEEE3D0)

**总结：以后分析代码的时候，就按照上面的思路走，主线程执行代码，创建调用栈，将全局执行上下文压入栈中，并且全局上下文中有个空的微任务队列，然后执行代码，遇到调用函数，则向调用栈中压入新的函数执行上下文，遇到宏任务放到消息队列中，遇到微任务放到微任务队列中，然后主线程每次执行完，在清空调用栈之前，先判断微任务队列中是否有任务，如果有则执行，如果没有，则清空调用栈，最后再依次执行消息队列中的宏任务。**
