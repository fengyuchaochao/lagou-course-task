# V8垃圾回收机制

在v8中，以下GC算法都会被用到：

* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量

![image](http://note.youdao.com/yws/res/10864/CD4F02B43BE74F96B1B3E88C42CA2635)

![image](http://note.youdao.com/yws/res/10074/96CC60D601E5423BBAB87D348029A6E6)

在v8中，会将内存空间分为两个区域：
* 新生代存储区
    * From
    * To
* 老生代存储区

**新生代存储区**：存放的是新生代对象，所谓新生代对象，其实就是一些存活时间比较短的对象，例如某个函数内部的局部变量，函数执行完以后，这些变量就被销毁了，所以他们就属于新生代对象，新生代存储区一般比较小（32M或16M）.

**老生代存储区**：存放的是老生代对象，所谓老生代对象，其实就是一些存活时间比较久的对象，例如一些全局对象，还有闭包。老生代存储区一般比较大（64位操作系统1.4G, 32位操作系统700M）


## 新生代对象的回收机制

回收过程采用：复制算法+标记整理

新生代存储区也会被一分为二：

* From：使用空间
* To：空闲空间

1. 将活动对象存储在From空间中，
2. 标记整理后，将活动对象拷贝至To中，
3. 最后将From空间完全释放掉，然后与To空间交换即可。

拷贝过程中，可能会出现晋升，所谓晋升，就是将新生代对象移动至老生代，常见以下两种情况都会出现晋升：
1. 一般一轮GC之后还存活的新生代对象就需要晋升（例如闭包）
2. 当To空间的使用率超过25%时，就会把To空间的对象移动至老生代存储区，因为当To空间如果使用吕较大时，它会和From空间进行交换，此时如果使用率较大，就无法存储新的活动对象了。

## 老生代对象的回收机制

主要采用标记清除，标记整理，标记增量算法进行回收。

![image](http://note.youdao.com/yws/res/10888/BC209D5BBA424F3BBE7B3AD965E0CB16)

即v8主要还是采用**标记清除**的算法对老生代对象进行回收，因为速度快呀，虽然会存在内存碎片化的问题，但是老生代存储区本身就比较大，

**当然如果出现内存不够的问题，也会采用标记整理的方式去整理内存**，例如：出现晋升的时候，即需要把新生代对象移动到老生代存储区时，此时如果发现内存空间不够了，就会触发标记整理的操作，从而优化内存空间，

最后说一下**增量标记**：其实就是因为垃圾回收本身是无法和程序并行执行的，也就是说垃圾回收时，程序只能处于等待状态，所以我们要尽量避免垃圾回收的时间太长，而v8对于老生代存储区主要是标记清除的方式，在标记这一步，我们没必要直接标记所有活动对象，而是分批区标记，也就说增量标记，从而和程序交替运行，

## 新老生代对象算法对比

* 新生代存储区采用空间换时间的思想：即存在空间复制这样一步，很显然复制操作，本身是耗内存的的，但是新生代存储区本身就比较小，所以相当对于是牺牲了空间，来换取更快的时间区进行垃圾回收。
* 而老生代存储区本身比较大，所以不太适合直接空间复制的算法。
