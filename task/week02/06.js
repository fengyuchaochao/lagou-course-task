/**
*
* 题目：简述symbol的用途
*
* Symbol最大特点就是可以生成一个唯一的值，所以只要以下几点用途：
 * 1. 用作对象的key，作为唯一值
 * 2. 实现类内部的私有属性
 * 3. 消除魔术字符串，即被重复定义和引用的字符串。
* */

/**
*
* 说说什么是浅拷贝，什么是深拷贝？
*
* 即浅拷贝只能拷贝对象的第一层，如果遇到嵌套的对象，必须通过深拷贝才能实现整个对象的拷贝，
*
* 浅拷贝以后，新生成的对象修改可能会影响以前的数据。
*
* 像我们平时所用的Object.assign()其实就是浅拷贝，哪想要实现深拷贝，一般可以采用如下方式：
*
* 1。 JSON.parse(Json.stringify());
* 2。 自定义深拷贝函数：和心思路就是利用递归，判断每一层的属性类型，如果是对象，则递归该函数。
* */

/**
* 简述ts与js的关系
*
* 平时大家可能会说ts是js的超集，其实简单来说，ts = js + es6+ + 类型系统，
*
* 相对于js而言，ts最大的区别还是提供了更加完备的类型系统，使其成为一门强类型语言，同时他又在js的基础上，提供了很多新特性，新功能。
*
* 在实际开发中，ts最终还是被编译成js，运行在浏览器或者其他环境中。
* */

/**
* 谈谈typescript的优缺点
*
*  优点：ts 很显然相对于js而言，功能更强大，类型系统也更加使得ts开发项目更加稳健，
*  缺点：
*
*  1。 ts提供了很多新增概念，例如接口，抽象类，泛型等概念，这些可能需要一些学习成本，
*  2。 ts本身提供的类型系统，所以需要我们每次都手动去声明这些类型，前期可能需要一些成本，但对于项目长期发展来说是有利的。
*
*
* */

/**
* 描述引用计数的工作原理以及优缺点
*
* 引用计数：核心就是内部维护着一个引用计数器，该引用计数器内部记录着各个对象的引用次数，并且会实时监控这些对象的引用关系，当引用关系发生改版时，引用计数器会实时修改这些对应的引用次数
*  当次数变成0的时候，就说明该对象就变成了垃圾，会被立即回收。
*
* 优点：可以实时立即回收垃圾，这样可以实时清理垃圾，释放内存空间，而不是隔一段时间再清理一次
* 缺点：主要是它需要维护一个引用计数器，需要记录这些对象的引用次数，而且需要不断修改，这个机制本身也是非常耗时的，而且对于那些循环引用的对象，因为引用次数无法被清零，所以无法被回收。
* */

/**
* 描述标记整理算法的工作流程
*
*  顾名思义：标记+整理
*
* 1. 标记；即遍历所有对象，把活动对象进行标记，
* 2. 整理：即标记之后，活动对象和非活动对象的内存位置可能都是不连续的，这样就带来一个问题，比如正好有一个1M的内存空间，还有一个2M的内存空间，我们假如有一个1.5M的对象要申请内存，这个时候，
*
*  1M的空间放不下，2M的空间又有点浪费，所有我们需要先进行标记整理，即移动对象的位置，把活动对象连续放在一起，非活动对象连续放在一起，这样清除非活动对象所占用的内存之后，就产生一块连续的内存空间
*
* */

/**
* 描述v8中新生代存储区的垃圾回收的流程
*
*  首先采用对from空间的对象进行标记整理，标记所有活动对象，并且 移动对象位置，
 *
 *  然后进行内存复制，将整个from空间所有活动对象拷贝到to空间，拷贝过程中，可能出现晋升，例如闭包，最后释放掉from空间。
 *
 *  最后，from空间与to空间进行交换。
*

* */
