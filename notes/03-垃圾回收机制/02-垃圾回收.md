# 垃圾回收


## 垃圾是如何产生的？

首先，在代码执行的过程中，我们在代码中声明的变量或者对象等数据都在内存中占用一块空间，随着而来，可能会产生一个无用的数据，这就是产生了垃圾。

注意：我们现在所说的垃圾回收机制都是在讨论代码在执行过程中产生的效果。


## 什么是垃圾？

这里首先给一个定义：当对象不再被引用，无法从根上访问到时，该对象就变成了垃圾。

另外有一点需要再次强调，我们这里所讲的垃圾回收机制都是针对引用类型数据来说的，因为普通类型数据都是直接存放在调用栈的执行上下文中，它的销毁是跟随执行上下文的出栈就销毁了，即普通类型数据的回收或者销毁，是由主线程来控制的。而引用类型数据的回收是通过垃圾回收机制控制的。

我们来通过实际代码体会一下：

```
let obj = {
    name: 'kobe'
};
// 经过一系列操作以后，手动置为null
obj = null;
```
我们可以看到，在全局执行上下文中，有一个obj指针，指向一块堆内存，该堆内存中存放着{name: 'kobe'} 这个对象/

然后经过一系列操作以后，如果觉得该对象没有用了，我们就可以手动把obj指针指向一个null，那此时{name: 'kobe'}所在堆内存区就变成了一块孤立的内存，没有其他任何指针指向该堆内存区，于是该堆内存区就变成了垃圾，等待被垃圾回收机制回收。

再来一个例子：
```
let obj = {
    name: 'kobe',
    detail: {
        age: 20
    }
};

delete obj.detail;
```
我们看到，obj有一个detail指针指向了一个对象{age: 20}, 然后我们使用delete操作符，删除了obj的属性detail，此时{age: 20}这个对象就无法再被引用到了，也就是说该对象变成了一个不可达对象，那它就变成了垃圾。


## GC算法

GC算法，即Garbage Collection 即垃圾回收机制。要做的事情就是：标识垃圾，找到垃圾，回收垃圾。

不同的GC算法，采用不同的方式去实现我们想要做的事情。

* 引用记数法
* 标记清除法
* 标记整理法
* 分代回收


最后再次强调一下：这里有一个非常重要的点，

我们都知道js代码在执行过程中，会维护一个调用栈，调用栈中存放的是执行上下文，执行上下文中存放的是基本类型数据，而引用类型数据其实是存放在堆中，执行上下文中只存放了引用类型数据的一个引用，

那对于基本类型数据类型，js代码在执行过程中，不断的进行入栈，出栈，所以**基本类型数据是否销毁是由主线程在执行过程中决定的，而垃垃圾回收机制主要处理的是引用类型数据**，例如某个堆内存的引用类型数据的引用被销毁了，那么它就变成了一个孤立的，没有任何引用的数据，那么该堆内存块就会被垃圾回收机制回收掉。
