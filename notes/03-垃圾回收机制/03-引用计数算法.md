# 引用记数算法


##  原理

引用计数算法的核心就是：它的内部会维护一个引用计数器，该引用计数器内部存储着各个对象或者变量的引用次数，如果次数不为0 ，说明该对象或者变量还依然再被使用，否则说明它没有什么用了，那么它所占用的内存就会被回收。

同时引用计数器会监控这些对象的引用情况，当对象的引用关系发生改变时，他们对象在引用计数器内相应的引用次数也会发生变化，当发现某些对应的引用次数为0，则会立即回收。


我们通过一段代码实际体会一下：

```
const user1 = {age: 1};

let ageList = [user1.age];

function fn () {
    const user2 = {age: 2};
}
fn();

```
我们分析一下：

上面的代码一共产生了两个对象：{age: 1}, {age:2} 他们分别存储在不同的堆内存中，{age: 1} 有两个引用：user1和ageList，而{age:2}有一个引用：user2,

代码执行完成以后，{age: 1}这个对象的引用并不会被销毁，因为它一直存在于全局执行上下文中，而{age:2}的引用user2则在fn函数执行完以后，就会被销毁了，此时{age:2}就变成了一个不可达对象，即就变成了垃圾，等待垃圾回收机制回收。


## 优缺点

优点：
* 发现垃圾时，立即进行回收
* 最大限度减少程序暂停：即会实时监控代码中的引用，如果发现有引用次数为0的对象，则会立即进行回收，可以尽量实时减少内存空间的占用。

缺点：
* 无法回收循环引用的对象，因为循环引用的对象，引用次数至少为1，不会被回收。
* 时间开销大，因为本身维护这些一个引用计数器，需要去记录这些对象的引用次数，而且需要不断修改，本身这个机制也是非常耗时的。

```
function fn () {
    let user1 = {name: 'user1'};
    let user2 = {name: 'user2'};
    user1.next = user2;
    user2.prev = user1;
}
fn();
```
例如上面这段代码，执行完成以后，user1和user2本来也应该被回收的，但是由于他们之间存在循环引用的关系，所以其实如果采用引用计数算法的话，user1和user2的引用次数都不为0，因此不会被回收。
